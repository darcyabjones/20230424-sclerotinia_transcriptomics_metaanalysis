---
title: "08-coexpression.Rmd"
output: html_document
date: "2023-07-04"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library("tidyverse")
library("UpSetR")
library("edgeR")
library("igraph")
library("ppcor")
source("code/PCAtest.R")
```

```{r}
ggplot2::theme_set(ggplot2::theme_bw() +
  ggplot2::theme(
    strip.background = element_rect(
     color="black", fill="white", linewidth=0, linetype="solid"
    ),
    rect = element_rect(
      colour = "black",
      linewidth = 1,
      linetype = "solid"
    )
  )
)

okabe <- c('#000000', '#E69F00', '#56B4E9', '#009E73', '#F0E042', '#0072B2', '#D55E00', '#CC79A7', '#999999')
options(ggplot2.discrete.fill = list(okabe[seq(2, 9, 2)], okabe[2:8], okabe, rep(okabe, 10)))
options(ggplot2.discrete.colour = list(okabe[seq(2, 9, 2)], okabe[2:8], okabe, rep(okabe, 10)))

gg_shape <- function(gg, vals) {gg + scale_shape_manual(values = rep(c(15, 17:20), 100))}
```

```{r, message=FALSE}
meta <- readr::read_tsv("input/sra_rnaseq2.tsv", na = "-")
orig_counts <- readr::read_tsv("output/feature_counts.tsv")
counts <- readr::read_tsv("output/feature_counts_deseq2_normed.tsv", na = "-")

counts <- dplyr::inner_join(
  meta,
  counts %>% pivot_longer(-id, names_to = "sra", values_to = "count"),
  by = "sra"
) %>%
dplyr::left_join(
  .,
  orig_counts %>% mutate(id = sub("gene-", "", Geneid)) %>% dplyr::select(id, gene_length = Length),
  by = "id"
) %>%
  dplyr::select(
    sra, bioproject,included,sample,
    organism,organism_tidyname,
    accession,accession_tidyname,
    host,host_tidyname,
    host_accession,host_accession_tidyname,
    tissue,hpi,plant_tissue,treatment,treatment_tidy,
    id,count,gene_length
  )

zero_counts <- counts %>% group_by(id) %>% summarise(count = sum(count)) %>% filter(count == 0.) %>% .[, "id"] %>% .[[1]]
counts <- counts %>% filter(!id %in% zero_counts)

rm(meta)
rm(orig_counts)

print(dim(counts))
head(counts)
```


There's a well known tendency for longer reads to have higher counts.
Normally this isn't a problem for DGE testing, because we're only comparing a gene with itself, so the length is constant.
However if we're looking for coexpression, we'll also be comparing the different gene lengths.
It may be fine if we use a metric that is unaffected by size (only correlation), like some of the rank methods.

So i'll have a look at out data to see if we need to normalise.

```
ggplot(counts, aes(x = gene_length, y = count)) +
  geom_point(size = 1, alpha = 0.6) +
  facet_wrap(vars(bioproject))
```

There's a slight tendency for longer genes to have higher values.
The smaller genes make up the majority of genes with high expression, but this is really just because large genes are very rare.

```
ggplot(counts, aes(x = gene_length, y = count)) +
  geom_point(size = 1, alpha = 0.6) +
  xlim(0, 2000) +
  facet_wrap(vars(bioproject))
```


So i'll divide the count by the gene length in kilobases.
This is roughly analogous to the common FPKM metric.

```
ggplot(counts, aes(x = gene_length, y = count / (gene_length / 1000))) +
  geom_point(size = 1, alpha = 0.6) +
  facet_wrap(vars(bioproject))
```


```
ggplot(counts, aes(x = gene_length, y = count / (gene_length / 1000))) +
  geom_point(size = 1, alpha = 0.6) +
  xlim(0, 2000) +
  facet_wrap(vars(bioproject))
```


I think actually that the unnormalised data looks ok.
And peaks we get at the lower values in the "normalised" counts worries me a bit.
It's probably fine either way, but I'll go with the unnormalised ones.




```{r}
this_counts <- lcounts %>% tidyr::pivot_wider(id_cols = c(id), names_from = sra, values_from = count) %>%
  column_to_rownames("id") %>%
  as.matrix()

this_meta <- meta %>% column_to_rownames("sra") %>% mutate(sample = factor(sample), bioproject = factor(bioproject)) %>% .[colnames(this_counts), ]
stopifnot(all(rownames(this_meta) == colnames(this_counts)))

dds <- DESeqDataSetFromMatrix(
  countData = this_counts,
  colData = this_meta,
  design = ~ sample
)
```


```{r}
corcounts <- vst(dds, blind = FALSE)
norm_counts_df <- assay(corcounts)

if ("disp_norm_count" %in% lcounts) {
  lcounts <- lcounts %>% select(-disp_norm_count)
}

lcounts <- left_join(
  lcounts,
  as.data.frame(norm_counts_df) %>% rownames_to_column("id") %>% tidyr::pivot_longer(-id, names_to = "sra", values_to = "disp_norm_count"),
  by = c("sra", "id")
)

```


```{r}
pca_raw <- princomp(norm_counts_df, fix_sign = TRUE)

prop_var <- ((pca_raw$sdev[1:10] / sum(pca_raw$sdev)) * 100) %>%
  data.frame(variance_explained = .) %>%
  rownames_to_column("PC") %>%
  mutate(PC = paste0("PC", sprintf("%02d", 1:n())))

print(prop_var)
ggplot(prop_var, aes(x=PC, y=variance_explained)) + geom_bar(stat = "identity")
```

```{r, fig.width = 10, fig.height = 10}
pca <- as.data.frame(pca_raw$loadings[, 1:10])
colnames(pca) <- paste0("PC", sprintf("%02d", seq_len(ncol(pca))))

pca <- pca %>% rownames_to_column("sra")
pca <- right_join(meta, pca, by = "sra")
gg1 <- pca %>%
  select(sra, host = host_tidyname, bioproject, PC01, PC02, PC03) %>%
  tidyr::pivot_longer(cols = c(PC01, PC02, PC03)) %>%
  full_join(., ., by=c("sra", "host", "bioproject")) %>%
  unique() %>%
  ggplot(aes(x=value.x, y=value.y, colour = host, shape = host)) +
  geom_point(size = 2, alpha = 0.6) +
  facet_grid(rows = vars(name.y), cols = vars(name.x), scales = "free") +
  theme(aspect.ratio = 1)

gg1 <- gg_shape(gg1, pca$host)

gg2 <- pca %>%
  select(sra, host = host_tidyname, bioproject, PC01, PC02, PC03) %>%
  tidyr::pivot_longer(cols = c(PC01, PC02, PC03)) %>%
  full_join(., ., by=c("sra", "host", "bioproject")) %>%
  unique() %>%
  ggplot(aes(x=value.x, y=value.y, colour = bioproject, shape = bioproject)) +
  geom_point(size = 2, alpha = 0.6) +
  facet_grid(rows = vars(name.y), cols = vars(name.x), scales = "free") +
  theme(aspect.ratio = 1)

gg2 <- gg_shape(gg2, pca$bioproject)
library(cowplot)

gg <- plot_grid(gg1, gg2, ncol = 1, align = "hv")
ggsave("output/deseq_norm_pca.svg", gg, height = 10, width = 10)
gg
```


```{r}
apply_tmm <- function(df) {
  # See: https://link.springer.com/article/10.1186/s13059-021-02568-9
  norm_factors <- calcNormFactors(df, method = "TMM")
  return((df - colMedians(df, na.rm = TRUE)) / norm_factors)
}

norm_counts_df_tmm <- apply_tmm(norm_counts_df)

if ("disp_norm_count_tmm" %in% lcounts) {
  lcounts <- lcounts %>% select(-disp_norm_count_tmm)
}

lcounts <- left_join(
  lcounts,
  as.data.frame(norm_counts_df_tmm) %>% rownames_to_column("id") %>% tidyr::pivot_longer(-id, names_to = "sra", values_to = "disp_norm_count_tmm"),
  by = c("sra", "id")
)


pca_raw <- princomp(norm_counts_df_tmm, fix_sign = TRUE)

prop_var <- ((pca_raw$sdev[1:10] / sum(pca_raw$sdev)) * 100) %>%
  data.frame(variance_explained = .) %>%
  rownames_to_column("PC") %>%
  mutate(PC = paste0("PC", sprintf("%02d", 1:n())))

print(prop_var)
ggplot(prop_var, aes(x=PC, y=variance_explained)) + geom_bar(stat = "identity")
```

```{r, fig.width = 10, fig.height = 10}
pca <- as.data.frame(pca_raw$loadings[, 1:10])
colnames(pca) <- paste0("PC", sprintf("%02d", seq_len(ncol(pca))))

pca <- pca %>% rownames_to_column("sra")
pca <- right_join(meta, pca, by = "sra")
gg1 <- pca %>%
  select(sra, host = host_tidyname, bioproject, PC01, PC02, PC03) %>%
  tidyr::pivot_longer(cols = c(PC01, PC02, PC03)) %>%
  full_join(., ., by=c("sra", "host", "bioproject")) %>%
  unique() %>%
  ggplot(aes(x=value.x, y=value.y, colour = host, shape = host)) +
  geom_point(size = 2, alpha = 0.6) +
  facet_grid(rows = vars(name.y), cols = vars(name.x), scales = "free") +
  theme(aspect.ratio = 1)

gg1 <- gg_shape(gg1, pca$host)

gg2 <- pca %>%
  select(sra, host = host_tidyname, bioproject, PC01, PC02, PC03) %>%
  tidyr::pivot_longer(cols = c(PC01, PC02, PC03)) %>%
  full_join(., ., by=c("sra", "host", "bioproject")) %>%
  unique() %>%
  ggplot(aes(x=value.x, y=value.y, colour = bioproject, shape = bioproject)) +
  geom_point(size = 2, alpha = 0.6) +
  facet_grid(rows = vars(name.y), cols = vars(name.x), scales = "free") +
  theme(aspect.ratio = 1)

gg2 <- gg_shape(gg2, pca$bioproject)
library(cowplot)

gg <- plot_grid(gg1, gg2, ncol = 1, align = "hv")
ggsave("output/deseq_norm_pca.svg", gg, height = 10, width = 10)
gg
```




```{r}
gen_count_matrix <- function(df) {
  #zero_counts <- df %>% group_by(id) %>% summarise(count = sum(count)) %>% filter(count == 0.) %>% .[, "id"] %>% .[[1]]
  df <- df %>%
    pivot_wider(id_cols = "id", names_from = "sra", values_from = "count") %>%
    column_to_rownames("id") %>%
    as.matrix()
  
  return(df)
}

cor.test.p <- function(x, direction = "both", method = "pearson") {
  stopifnot(direction %in% c("up", "down", "both"))
  stopifnot(method %in% c("pearson", "spearman"))
  n <- (!is.na(x)) %*% t(!is.na(x))
  r <- cor(t(x), method = method, use = "pairwise.complete.obs")
  
  if (method %in% c("pearson", "spearman")) {
    t <- (r * sqrt(n - 2)) / sqrt(1 - r^2)
    if (direction == "up") {
      p <- pt(t, (n - 2), lower.tail = FALSE)
    } else if (direction == "down") {
      p <- pt(t, (n - 2), lower.tail = TRUE)
    } else {
      p <- 2 * pt(abs(t), (n - 2), lower.tail = FALSE)
    }
  } else if (method == "kendall") {
    p <- NULL
  } else {
    stop("Don't be silly darcy")
  }
  return(p)
}
```

```{r}
collapse_duplicates <- function(mat, precision = 4) {
  strings <- data.frame(
    id = rownames(mat),
    counts = do.call(paste, as.data.frame(round(mat, precision)))
  )

  strings <- strings %>%
    group_by(counts) %>%
    summarise(n = n_distinct(id), ids = paste0(unique(id), collapse = "__"), rep = first(id))

  strings <- strings[order(strings$ids), ]

  new_mat <- mat[strings[["rep"]], ]
  rownames(new_mat) <- strings[["ids"]]
  return(new_mat)
}
```

```{r}
collapse_approx_duplicates <- function(mat, method = "pearson", precision = (1 - 1e-5)) {
  cor_mat <- cor(t(mat), method = method) >= precision
  
  adj <- graph_from_adjacency_matrix(cor_mat, mode = "undirected", diag = TRUE)
  tmp <- components(adj)$membership

  gvar <- apply(mat, MARGIN = 1, var, na.rm = TRUE)
  gvar[is.na(gvar)] <- 0
  
  tmp <- data.frame(id = names(tmp), component = unname(tmp))
  gvar <- data.frame(id = names(gvar), var = unname(gvar))
  tmp <- left_join(
    tmp,
    gvar,
    by = "id"
  )

  tmp <- tmp[order(tmp$var, decreasing = TRUE, na.last = TRUE), ] %>%
    group_by(component) %>%
    summarise(rep = first(id), id = paste(id, collapse = "__", sep = "__"))
  
  new_mat <- mat[tmp[["rep"]], ]
  rownames(new_mat) <- tmp[["id"]]
  return(new_mat)
}
```

```{r, warning=FALSE}
ctest <- gen_count_matrix(counts %>% filter(host_tidyname == "Atha"))

ctest <- collapse_duplicates(ctest)
ctest <- collapse_approx_duplicates(ctest)
gene_sds <- apply(ctest, MARGIN = 1, FUN = sd)

ctest <- ctest[(!is.na(gene_sds)) & (gene_sds > 0) & (rowSums(ctest, na.rm = TRUE) > 0), ]

# See: https://link.springer.com/article/10.1186/s13059-021-02568-9
norm_factors <- calcNormFactors(ctest)
ctest <- (ctest - colMeans(ctest)) / norm_factors


npcs  <- PCAtest(ctest)$nsig

ctest_pca <- prcomp(ctest)$x[, 1:npcs]
ctp1 <- cor.test.p(ctest_pca, direction = "up")
ctp1[1:5, 1:5]
```



```{r}
library("parmigene")
```

```{r}
mi <- knnmi.all(mat = ctest_pca, k = 3)
mi[1:5, 1:5]
```

```{r}
clr_mi <- clr(mi)
#clr_mi <- clr_mi / max(clr_mi)
```

```{r}
heatmap(clr_mi[1:1000, 1:1000], symm = TRUE, scale = "none")
```

```{r}
clr_pvals <- 2 * pnorm(clr_mi, lower.tail = FALSE)
heatmap(clr_pvals[1:100, 1:100], symm = TRUE, scale = "none")
```


```{r}
unify <- function(m) {
    m[lower.tri(m)] <- t(m)[lower.tri(m)]
    m
}

p.adjust.square <- function(mat, method = "BH") {
  # Uncertain whether NA will mutate outer matrix.
  # So i make copy.
  mat_ <- mat
  mat_[lower.tri(mat, diag = TRUE)] <- NA

  adj <- p.adjust(mat_, method = "BH")
  adj <- matrix(adj, nrow = nrow(mat), ncol = ncol(mat))

  adj <- unify(adj)
  diag(adj) <- 0

  colnames(adj) <- colnames(mat)
  rownames(adj) <- rownames(mat)
  return(adj)
}

ctp1_adj <- p.adjust.square(ctp1)
#ctp1_adj <- p.adjust.square(clr_pvals)
ctp1_adj[1:5, 1:5]
```


```{r}
ctpl <- ctp1_adj <= 0.01
ctpl[is.na(ctpl)] <- FALSE
ctp1_adj_trimmed <- -log(ctp1_adj)
#ctp1_adj_trimmed <- 1 - ctp1_adj
#ctp1_adj_trimmed[!ctpl] <- 0
ctp1_adj_trimmed[!is.finite(ctp1_adj_trimmed)] <- max(ctp1_adj_trimmed[is.finite(ctp1_adj_trimmed)])
ctp1_adj_trimmed[1:5, 1:5]
```


```{r}
adj <- graph_from_adjacency_matrix(ctp1_adj_trimmed, mode = "undirected", diag = FALSE, weighted = TRUE)
#adj <- graph_from_adjacency_matrix(ctpl, mode = "undirected", diag = FALSE, weighted = TRUE)
#adj <- graph_from_adjacency_matrix(clr_mi, mode = "undirected", diag = FALSE, weighted = TRUE)
adj
```

```{r}
tmp <- components(adj)$membership
tmp2 <- data.frame(id = names(tmp), component = unname(tmp))
tmp3 <- tmp2 %>% group_by(component) %>% summarise(n_distinct(id))
tmp3[order(tmp3$`n_distinct(id)`, decreasing = TRUE), ]
```


```{r}
cluster <- tmp2 %>% filter(component == 18) %>% dplyr::select(id) %>% .[[1]]
ctest2 <- ctest[rownames(ctest) %in% cluster, ]
heatmap(ctest2, col = heat.colors(50))

legend(x="bottomright", legend = c(min(ctest2), mean(ctest2), max(ctest2)), fill=heat.colors(3))
```


```{r}
clusters <- cluster_leiden(adj)
tmp2 <- data.frame(id = attr(V(adj), "names"), component = clusters$membership)
tmp3 <- tmp2 %>% group_by(component) %>% summarise(n_distinct(id))
tmp3[order(tmp3$`n_distinct(id)`, decreasing = TRUE), ]
```

```{r}
cluster <- tmp2 %>% filter(component == 20) %>% dplyr::select(id) %>% .[[1]]
ctest2 <- ctest_pca[rownames(ctest_pca) %in% cluster, ]
heatmap(ctest2, col = heat.colors(50))

legend(x="bottomright", legend = c(min(ctest2), mean(ctest2), max(ctest2)), fill=heat.colors(3))
```

```{r}
cluster <- tmp2 %>% filter(component == 32) %>% dplyr::select(id) %>% .[[1]]
ctest2 <- ctest_pca[rownames(ctest_pca) %in% cluster, ]
heatmap(ctest2, col = heat.colors(50))

legend(x="bottomright", legend = c(min(ctest2), mean(ctest2), max(ctest2)), fill=heat.colors(3))
```


```{r}
cluster <- tmp2 %>% filter(component == 11) %>% dplyr::select(id) %>% .[[1]]
ctest2 <- ctest_pca[rownames(ctest_pca) %in% cluster, ]
heatmap(ctest2, col = heat.colors(50))

legend(x="bottomright", legend = c(min(ctest2), mean(ctest2), max(ctest2)), fill=heat.colors(3))
```


```{r}
p <- pcor(t(ctest2), method = "spearman")
pestimate <- p$estimate
colnames(pestimate) <- rownames(pestimate) <- rownames(ctest2)
heatmap(pestimate[1:100, 1:100], symm = TRUE, col = heat.colors(50))
legend(x="bottomright", legend = c(min(p$estimate), mean(p$estimate), max(p$estimate)), fill=heat.colors(3))
```



```{r}
#unify <- function(m) {
#    m[lower.tri(m)] <- t(m)[lower.tri(m)]
#    m
#}

d <- p$statistic
rownames(d) <- colnames(d) <- rownames(ctest2)

print(d[1:5, 1:5])
d[lower.tri(d)] <- ifelse(is.na(d[lower.tri(d)]), t(d)[lower.tri(d)], d[lower.tri(d)])
d[upper.tri(d)] <- ifelse(is.na(d[upper.tri(d)]), t(d)[upper.tri(d)], d[upper.tri(d)])
#d[is.na(d)] <- 0
#heatmap(d[1:100, 1:100], symm = TRUE, scale = "none")

diag(d) <- NaN
#d[is.na(d)] <- 0
#d[d < 0] <- NaN
d[1:5, 1:5]
```

```{r}
all_missing <- !apply(is.na(d), MARGIN = 1, FUN = all)
sum(all_missing)
d2 <- d[all_missing, all_missing]
d2[is.na(d2)] <- 0
pvals <- 2 * pt(abs(d2), ncol(d2) - 2, lower.tail = FALSE)
heatmap(pvals[1:100, 1:100], symm = TRUE, scale = "none")
```

```{r}
dist_ <- dist(pvals)
hcl <- hclust(dist_)
heatmap(ctest2[all_missing,], Rowv = as.dendrogram(hcl))
```

```{r}
adj <- graph_from_adjacency_matrix(pvals, mode = "undirected", diag = FALSE, weighted = TRUE)
adj
```

```{r}
clusters <- cluster_louvain(adj)
tmp2 <- data.frame(id = attr(V(adj), "names"), component = clusters$membership)
tmp3 <- tmp2 %>% group_by(component) %>% summarise(n_distinct(id))
tmp3[order(tmp3$`n_distinct(id)`, decreasing = TRUE), ]
```

```{r}
cluster <- tmp2 %>% filter(component == 1) %>% dplyr::select(id) %>% .[[1]]
ctest3 <- ctest_pca[rownames(ctest_pca) %in% cluster, ]
heatmap(ctest3, col = heat.colors(50))

legend(x="bottomright", legend = c(min(ctest3), mean(ctest3), max(ctest3)), fill=heat.colors(3))
```

```{r}
cluster <- tmp2 %>% filter(component == 2) %>% dplyr::select(id) %>% .[[1]]
ctest3 <- ctest_pca[rownames(ctest_pca) %in% cluster, ]
heatmap(ctest3, col = heat.colors(50))

legend(x="bottomright", legend = c(min(ctest3), mean(ctest3), max(ctest3)), fill=heat.colors(3))
```


```{r}
library(ica)
```

```{r}
m <- ica(ctest, 8, method = "jade")
heatmap(m$S[1:1000,], scale = "none")
```

```{r}
heatmap(m$M)
```











